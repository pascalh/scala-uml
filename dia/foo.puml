@startuml need_to_find_id
package uml{
    class uml.umlMethods << object >>{
        toExternalAssociationsRep : State<UMLElement,Tuple2<List<RelationshipElement>,List<RelationshipElement>>> 
         : State 
         : State 
        - startState< T > (start : T) : State <UMLElement, T>
        - nextRewriteState< T > (start : T) (rewriteStrategy : RewriteStrategy <T>) : State <UMLElement, T>
        - nextCollectState< T > (start : T) (collectStrategy : CollectStrategy <T>) : State <UMLElement, T>
        exclude (umlElement : UMLElement,  f : Filter) : Eval <UMLElement>
        - classesAndCompanion (allClasses : List <Class>) 
        toPackageRep (umlElement : UMLElement) : Eval <UMLElement>
        insertCompanionObjects (umlUnit : UMLUnit) : Eval <UMLUnit>
        toAssocRep (umlElement : UMLElement) : Eval <UMLElement> 
    
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Relationship 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Relationship 
         
    }
    class uml.Relationship << caseclass >>{
        << ctor >>Relationship (relationshipType : RelationshipType,  relationshipDirection : RelationshipDirection,  relationshipInfo : RelationshipInfo,  stereotype : List <Stereotype>) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <Relationship>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : RelationshipInfo 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : RelationshipInfo 
         
    }
    class uml.RelationshipInfo << caseclass >>{
        << ctor >>RelationshipInfo (sourceMultiplicity : Option <String>,  targetMultiplicity : Option <String>,  from : RelationshipElement,  to : RelationshipElement,  relationshipIdentifier : Option <String>,  identifierDirection : RelationshipDirection,  originType : ClassType) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <RelationshipInfo>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : PackageRef 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : PackageRef 
         
    }
    class uml.PackageRef << caseclass >>{
        toString : String 
        << ctor >>PackageRef (namespace : NamespaceEntry) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <PackageRef>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : ClassRef 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : ClassRef 
         
    }
    class uml.ClassRef << caseclass >>{
        << ctor >>ClassRef (name : String,  namespace : Entry) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <ClassRef>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : ConcreteClass 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : ConcreteClass 
         
    }
    class uml.ConcreteClass << caseclass >>{
        << ctor >>ConcreteClass (cls : Class) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <ConcreteClass>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.RelationshipElement << trait >>{
         -- <<scalaclass>> --
        isSealed
    }
    class uml.Without << caseobject >>
    class uml.ToFrom << caseobject >>
    class uml.FromTo << caseobject >>
    abstract class uml.RelationshipDirection << trait >>{
         -- <<scalaclass>> --
        isSealed
    }
    class uml.Inner << caseobject >>
    class uml.Association << caseobject >>
    class uml.Annotation << caseobject >>
    class uml.Aggregation << caseobject >>
    class uml.Composition << caseobject >>
    class uml.Realization << caseobject >>
    class uml.Extension << caseobject >>
    abstract class uml.RelationshipType << trait >>{
         -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Compartment 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Compartment 
         
    }
    class uml.Compartment << caseclass >>{
        << ctor >>Compartment (identifier : Option <String>,  taggedValues : List <TaggedValue>,  stereotype : List <Stereotype>) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <Compartment>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Operation 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Operation 
         
    }
    class uml.Operation << caseclass >>{
        << ctor >>Operation (modificator : Option <List <Modificator>>,  accessModifier : Option <AccessModifier>,  name : String,  paramSeq : List <List <Parameter>>,  returnType : Option <Type>,  stereotype : List <Stereotype>,  templateParameter : Option <List <GenericParameter>>) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <Operation>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Parameter 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Parameter 
         
    }
    class uml.Parameter << caseclass >>{
        << ctor >>Parameter (name : String,  paramType : Type,  stereotype : List <Stereotype>) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <Parameter>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : RefPathQualifier 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : RefPathQualifier 
         
    }
    class uml.RefPathQualifier << caseclass >>{
        << ctor >>RefPathQualifier (path : List <String>,  target : String) 
        pretty (<< implicit >>pretty : PrettyPrinter <T>) : String
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement> 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : RefTemplate 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : RefTemplate 
         
    }
    class uml.RefTemplate << caseclass >>{
        << ctor >>RefTemplate (preType : Type,  templateTypes : List <Type>) 
        pretty (<< implicit >>pretty : PrettyPrinter <T>) : String
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement> 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : RefName 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : RefName 
         
    }
    class uml.RefName << caseclass >>{
        << ctor >>RefName (name : String,  namespace : Entry,  metaOrigin : Option <Stat>) 
        pretty (<< implicit >>pretty : PrettyPrinter <T>) : String
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement> 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.Type << trait >>{
         -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Attribute 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Attribute 
         
    }
    class uml.Attribute << caseclass >>{
        << ctor >>Attribute (modificators : Option <List <Modificator>>,  modifier : Option <AccessModifier>,  name : String,  attributeType : Option <String>,  stereotype : List <Stereotype>,  defaultValue : Option <String>) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <Attribute>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Class 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Class 
         
    }
    class uml.Class << caseclass >>{
        << ctor >>Class (isAbstract : Boolean,  name : String,  attributes : List <Attribute>,  operations : List <Operation>,  additionalCompartements : List <Compartment>,  genericParameters : Option <List <GenericParameter>>,  stereotype : List <Stereotype>,  namespace : Entry) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <Class>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    class uml.externalReferences << object >>
    class uml.Abstract << caseobject >>
    class uml.Static << caseobject >>
    abstract class uml.Modificator << trait >>{
         -- <<scalaclass>> --
        isSealed
    }
    class uml.Public << caseobject >>
    class uml.PackagePrivate << caseobject >>
    class uml.Protected << caseobject >>
    class uml.Private << caseobject >>
    abstract class uml.AccessModifier << trait >>{
         -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : GenericParameter 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : GenericParameter 
         
    }
    class uml.GenericParameter << caseclass >>{
        << ctor >>GenericParameter (name : String,  concreteType : Option <String>,  stereotype : List <Stereotype>) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <GenericParameter>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Package 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Package 
         
    }
    class uml.Package << caseclass >>{
        << ctor >>Package (packageBodyElements : List <PackageBodyElement>,  stereotype : List <Stereotype>,  namespace : Entry) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <Package>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : UMLUnit 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : UMLUnit 
         
    }
    class uml.UMLUnit << caseclass >>{
        << ctor >>UMLUnit (name : String,  toplevelElements : List <TopLevelElement>) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <UMLUnit>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Stereotype 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : Stereotype 
         
    }
    class uml.Stereotype << caseclass >>{
        << ctor >>Stereotype (name : String,  taggedValues : List <TaggedValue>) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <Stereotype>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : TaggedValue 
         
    }
    abstract class uml.T << type >>{
        << typeDef >>_type_ : TaggedValue 
         
    }
    class uml.TaggedValue << caseclass >>{
        << ctor >>TaggedValue (name : String,  value : Option <String>) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <TaggedValue>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.NamedElement << trait >>{
        name : String 
         -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.PackageBodyElement << trait >>{
         -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.CompartmentElement << trait >>{
         -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.TopLevelElement << trait >>{
        namespace : Entry 
         -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.StereotypeElement << trait >>{
        stereotype : List<Stereotype> 
         -- <<scalaclass>> --
        isSealed
    }
    abstract class uml.T << type >>
    abstract class uml.T << type >>
    abstract class uml.UMLElement << trait >>{
        pretty (<< implicit >>pretty : PrettyPrinter <T>) : String
        structure  : String
        rewrite< T > (s : Function1 <T, Strategy>) (startState : T) (f : Function2 <UMLElement, T, T>) : Eval <Tuple2 <T, UMLElement>>
        collect< B > (pf : ==> <UMLElement, B>) : List <B>
        contains< B > (elem : UMLElement) : Boolean
        count (p : Function1 <UMLElement, Boolean>) : Int
        map (f : ==> <UMLElement, UMLElement>) : UMLElement
        forall (p : Function1 <UMLElement, Boolean>) : Boolean
        exists (p : Function1 <UMLElement, Boolean>) : Boolean
        toList  : List <UMLElement>
         {static} # accStart< T, U : HigherBound<UMLElement>  >  : State <T, List <U>>
         {static} # accInnerStart< T, U : HigherBound<UMLElement>  >  : State <T, List <List <U>>>
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
         {static} # rewriteList< T > (s : State <T, Strategy>,  f : Function1 <UMLElement, State <T, Unit>>,  elements : List <UMLElement>) : State <T, List <UMLElement>>
         {static} # rewriteListList< T > (s : State <T, Strategy>,  f : Function1 <UMLElement, State <T, Unit>>,  elementss : List <List <UMLElement>>) : State <T, List <List <UMLElement>>>
        # rewriteOptionList< T > (s : State <T, Strategy>,  f : Function1 <UMLElement, State <T, Unit>>,  option : Option <List <UMLElement>>) : State <T, Option <List <UMLElement>>>
        # listStructure< T : HigherBound<UMLElement>  > (umlElements : List <T>) : String
        # optionString (os : Option <String>) : String
        # optionUMLElement (oElement : Option <UMLElement>) : String
        # optionAny< T > (oA : T) : String 
    -- <<scalaclass>> --
        isSealed
    }
}
package uml::externalReferences{
    abstract class uml::externalReferences.T << type >>{
        << typeDef >>_type_ : ClassDefRef 
         
    }
    abstract class uml::externalReferences.T << type >>{
        << typeDef >>_type_ : ClassDefRef 
         
    }
    class uml::externalReferences.ClassDefRef << caseclass >>{
        << ctor >>ClassDefRef (classtype : ClassType,  name : String,  namespace : Entry,  templateParameter : List <String>,  oStat : Option <Stat>) 
        structure  : String
        rewrite< T > (s : State <T, Strategy>) (f : Function1 <UMLElement, State <T, Unit>>) : State <T, UMLElement>
        pretty (<< implicit >>pretty : PrettyPrinter <ClassDefRef>) : String 
    -- <<scalaclass>> --
        isSealed
    }
    class uml::externalReferences.CCaseClass << caseobject >>
    class uml::externalReferences.CClass << caseobject >>
    class uml::externalReferences.Object << caseobject >>
    class uml::externalReferences.Enum << caseobject >>
    class uml::externalReferences.Trait << caseobject >>
    abstract class uml::externalReferences.ClassType << trait >>{
         -- <<scalaclass>> --
        isSealed
    }
}
uml.UMLElement +-- uml.T 
uml.UMLElement <|-- uml.StereotypeElement 
uml.UMLElement <|-- uml.TopLevelElement 
uml.UMLElement <|-- uml.CompartmentElement 
uml.UMLElement <|-- uml.PackageBodyElement 
uml.UMLElement <|-- uml.NamedElement 
uml.TaggedValue +-- uml.T 
uml.NamedElement <|-- uml.TaggedValue 
uml.Stereotype +-- uml.T 
uml.NamedElement <|-- uml.Stereotype 
uml.UMLUnit +-- uml.T 
uml.NamedElement <|-- uml.UMLUnit 
uml.Package +-- uml.T 
uml.TopLevelElement <|-- uml.Package 
uml.PackageBodyElement <|-- uml.Package 
uml.StereotypeElement <|-- uml.Package 
uml.GenericParameter +-- uml.T 
uml.StereotypeElement <|-- uml.GenericParameter 
uml.NamedElement <|-- uml.GenericParameter 
uml.AccessModifier <|-- uml.Private 
uml.AccessModifier <|-- uml.Protected 
uml.AccessModifier <|-- uml.PackagePrivate 
uml.AccessModifier <|-- uml.Public 
uml.Modificator <|-- uml.Static 
uml.Modificator <|-- uml.Abstract 
uml::externalReferences.ClassType <|-- uml::externalReferences.Trait 
uml::externalReferences.ClassType <|-- uml::externalReferences.Enum 
uml::externalReferences.ClassType <|-- uml::externalReferences.Object 
uml::externalReferences.ClassType <|-- uml::externalReferences.CClass 
uml::externalReferences.ClassType <|-- uml::externalReferences.CCaseClass 
uml::externalReferences.ClassDefRef +-- uml::externalReferences.T 
uml.TopLevelElement <|-- uml::externalReferences.ClassDefRef 
uml.NamedElement <|-- uml::externalReferences.ClassDefRef 
uml.Class +-- uml.T 
uml.TopLevelElement <|-- uml.Class 
uml.StereotypeElement <|-- uml.Class 
uml.PackageBodyElement <|-- uml.Class 
uml.NamedElement <|-- uml.Class 
uml.Attribute +-- uml.T 
uml.CompartmentElement <|-- uml.Attribute 
uml.StereotypeElement <|-- uml.Attribute 
uml.NamedElement <|-- uml.Attribute 
uml.UMLElement <|-- uml.Type 
uml.RefName +-- uml.T 
uml.Type <|-- uml.RefName 
uml.RefTemplate +-- uml.T 
uml.Type <|-- uml.RefTemplate 
uml.RefPathQualifier +-- uml.T 
uml.Type <|-- uml.RefPathQualifier 
uml.Parameter +-- uml.T 
uml.StereotypeElement <|-- uml.Parameter 
uml.NamedElement <|-- uml.Parameter 
uml.Operation +-- uml.T 
uml.CompartmentElement <|-- uml.Operation 
uml.StereotypeElement <|-- uml.Operation 
uml.NamedElement <|-- uml.Operation 
uml.Compartment +-- uml.T 
uml.UMLElement <|-- uml.Compartment 
uml.StereotypeElement <|-- uml.Compartment 
uml.RelationshipType <|-- uml.Extension 
uml.RelationshipType <|-- uml.Realization 
uml.RelationshipType <|-- uml.Composition 
uml.RelationshipType <|-- uml.Aggregation 
uml.RelationshipType <|-- uml.Annotation 
uml.RelationshipType <|-- uml.Association 
uml.RelationshipType <|-- uml.Inner 
uml.RelationshipDirection <|-- uml.FromTo 
uml.RelationshipDirection <|-- uml.ToFrom 
uml.RelationshipDirection <|-- uml.Without 
uml.UMLElement <|-- uml.RelationshipElement 
uml.ConcreteClass +-- uml.T 
uml.RelationshipElement <|-- uml.ConcreteClass 
uml.ClassRef +-- uml.T 
uml.RelationshipElement <|-- uml.ClassRef 
uml.PackageRef +-- uml.T 
uml.RelationshipElement <|-- uml.PackageRef 
uml.RelationshipInfo +-- uml.T 
uml.UMLElement <|-- uml.RelationshipInfo 
uml.Relationship +-- uml.T 
uml.TopLevelElement <|-- uml.Relationship 
uml.PackageBodyElement <|-- uml.Relationship 
uml.StereotypeElement <|-- uml.Relationship 
uml.externalReferences +-- uml::externalReferences : << objectdef >>
@enduml