@startuml need_to_find_id
package ast{
    class ast.Value << caseclass >>{
        << ctor >>Value (v : Int) 
        foldLeft< T, C > (start : T) (op : Func<Tuple2<T,ArithExpr>,T>) : T 
    -- <<scalaclass>> --
        isSealed
    }
    class ast.Div << caseclass >>{
        << ctor >>Div (v1 : ArithExpr,  v2 : ArithExpr) 
        foldLeft< T, C > (start : T) (op : Func<Tuple2<T,ArithExpr>,T>) : T 
    -- <<scalaclass>> --
        isSealed
    }
    class ast.Mult << caseclass >>{
        << ctor >>Mult (v1 : ArithExpr,  v2 : ArithExpr) 
        foldLeft< T, C > (start : T) (op : Func<Tuple2<T,ArithExpr>,T>) : T 
    -- <<scalaclass>> --
        isSealed
    }
    class ast.Sub << caseclass >>{
        << ctor >>Sub (v1 : ArithExpr,  v2 : ArithExpr) 
        foldLeft< T, C > (start : T) (op : Func<Tuple2<T,ArithExpr>,T>) : T 
    -- <<scalaclass>> --
        isSealed
    }
    class ast.Add << caseclass >>{
        << ctor >>Add (v1 : ArithExpr,  v2 : ArithExpr) 
        foldLeft< T, C > (start : T) (op : Func<Tuple2<T,ArithExpr>,T>) : T 
    -- <<scalaclass>> --
        isSealed
    }
    class ast.$ArithExpr << object >>{
        apply (arth : String) : ArithExpr 
    
    }
    abstract class ast.ArithExpr << trait >>{
        foldLeft< T, C > (start : T) (op : Func<Tuple2<T,ArithExpr>,T>) : T 
    
    }
}
ast.ArithExpr <|-- ast.Add 
ast.ArithExpr <|-- ast.Sub 
ast.ArithExpr <|-- ast.Mult 
ast.ArithExpr <|-- ast.Div 
ast.ArithExpr <|-- ast.Value 
ast.ArithExpr .. ast.$ArithExpr : << companion >>
@enduml